
import sys
import os
import numpy as np
import scipy.cluster.vq_maohz as scv
import pickle

from layer_dump import *

import argparse

parser = argparse.ArgumentParser()
parser.add_argument('--layer', type = str, default = 'fc6')
parser.add_argument('--bank-num', type = int, default = 64)
parser.add_argument('--buffersize', type = int, default = 8)
parser.add_argument('--ind-bits', type = int, default = 4)
parser.add_argument('--sram-line', type = int, default = 64)

W_ = pickle.load(open('/home/maohz12/dnn_simulator/data_rnn/coco_1.6.pkl'))

class blob(object):
    def __init__(self, W):
        self.data = W.astype(np.float32)
class fakenet(object):
    def __init__(self, W):
        self.params = {}
        for key in W:
            self.params[key] = [blob(W[key].transpose())]
            self.params[key].append(blob(np.zeros(W[key].shape[1])))

net = fakenet(W_)

options = parser.parse_args()
key = options.layer
bank_num = options.bank_num
buffer_size = options.buffersize
max_jump = 2 **  options.ind_bits
spm_unitsize = options.sram_line / 8

codebook = kmeans(net, [key])
codes_W, codes_b = get_codes(net, codebook)
ptr, spm, ind, layer_shift= get_csc(codes_W, codes_b, bank_num = bank_num, max_jump = 16)
act = np.ones(W_[key].shape[0], dtype = np.float32)
ground_truth = np.dot(net.params[key][0].data, act) + net.params[key][1].data

simulator_root = os.environ['SIMULATOR_PATH']
os.system("rm -rf %s/data/ptr"%simulator_root)
os.system("rm -rf %s/data/spm"%simulator_root)
os.system("mkdir %s/data/ptr"%simulator_root)
os.system("mkdir %s/data/spm"%simulator_root)

max_memsize = 0
mem_a = [0] * bank_num
for idx in range(bank_num):
    with open("%s/data/ptr/ptr%d.dat"%(simulator_root, idx), 'wb') as f:
        ptr[idx].tofile(f)

    with open("%s/data/spm/spm%d.dat"%(simulator_root, idx), 'wb') as f:
        mem = np.transpose(np.array([spm[idx],ind[idx]])).flatten()
        if (mem.size > max_memsize):
            max_memsize = mem.size
        mem.tofile(f)
        mem_a[idx] = mem

with open("%s/data/arithm.dat"%simulator_root, 'wb') as f:
    for key in codebook:
        codebook_t = np.array(codebook[key], dtype=np.float32)
        codebook_t.tofile(f)
    
# Render config header file
template = r'''
// Auto generated by script/layer_dump.py

#ifndef PARAMS
#define PARAMS

// Config harware
const int NUM_PE = {{ bank_num }};
const int ACTRW_maxcapacity = {{ max_size }};
const int NZFETCH_buffersize = {{ buffer_size }};  
const int PTRVEC_num_lines = {{ ptr_lines }};  
const int SPMAT_unit_line   =  {{ spm_unitsize }};  // Nzeros per line
const int SPMAT_num_lines   =  {{ spm_lines }}; 
const int SPMAT_index_bits  =  4;  
const int SPMAT_weights_bits=  4;  
const int ARITHM_codebooksize = 16;

// Config input data
const int ACT_length = {{act_length}};
#endif
'''
###################################################
# Configuration

##################################################

max_inputsize = max(act.size, ground_truth.size)
act_length = act.size

jtem = Template(template)
config_file = jtem.render(bank_num = bank_num, ptr_lines = ptr[0].size, 
    spm_unitsize = spm_unitsize, spm_lines = (max_memsize - 1) / spm_unitsize / 2 + 1, 
    max_size = max_inputsize, act_length = act_length, buffer_size = buffer_size)

with open("%s/data/act.dat"%simulator_root, 'wb') as f:
    act.tofile(f)

with open("%s/data/groundtruth.dat"%simulator_root, 'wb') as f:
    ground_truth.tofile(f)
 
with open("%s/src/params.h"%(simulator_root), 'w') as f:
    f.write(config_file)

